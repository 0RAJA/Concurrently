package main

/*
	Go语言并发原语
	CSP（通信顺序进程)
为了在进程之间进行通信， Hoare 创造了输入与输出的命令：
	！代表发送输入到一个进程,
	? 代表从一个进程接收输出。
每一个指令都需要指定具体是一个输出变量（从一个进程中读取一个变量的情况） 还是一个目的地（将输入发送到一个进程的情况）。
一个进程的输出应该直接流入另一个进程的输入。
例子：
	cardreader?cardimage 					从 cardreader 中读取一条记录，并将它的值 (一个数组) 赋给变量cardimage
	lineprinter!lineimage  					向 lineprinter 发送 lineimage 的值
	x?(x,y)									从 x 进程中读取一对值，并将它们赋给变量x,y
	DIV!(3*a+b,13) 							处理 DIV, 输出两个指定的值
	*[c:character;west?c->east!c] 			读取所有 west 输出的字符，然后输出到 east 。当 过程 wes 结束时，终止
*/
/*
	Go 语言确实在 sync 提供了传统的锁机制 大多数的锁问题都 以通过 chan 或者传统的销两者之一来解决
	所以说，我该用哪个？
		使用最好描述和最简单的那个方式。
			使用锁：
				对性能要求高的临界区
					万不得已时使用锁可以提高性能。
				试图保护某个结构的内部状态
					比如为了保证一个结构内部的变量的并发安全，这可以使用锁。
			使用channel：
				试图转让数据的所有权
					需要将计算结果共享给其他代码块的代码时。
					数据拥有所有者，并发程序安全就是保证同时只有一个并发上下文拥有数据所有权。可以通过带缓存的channel来解藕生产者和消费者
				试图协调多个逻辑片段
					协调多个线程之间的并发关系时可以使用channel
*/
func main() {

}
